{"task":"Verify build_metric for NatÃ¡rio metric with 1-meter rings","priority":"High","source_file":"src/supraluminal_prototype/warp_generator.py","source_file_lines":"50:65","source_snippet":"def build_metric(self, params): ...","python_snippet":"import numpy as np\nfrom supraluminal_prototype.warp_generator import WarpFieldGenerator\nxs = np.linspace(-1,1,16)\ngen = WarpFieldGenerator(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nG = gen.build_metric({'r_eff':1e-10,'v':3e8})\nassert G.shape == (4,4,16,16,16)\nr2 = sum(xi**2 for xi in np.meshgrid(xs,xs,xs,indexing='ij'))\nassert np.allclose(G[0,0], np.exp(-r2))"}
{"task":"Test plasma_density and field_propagation for 5-meter bubble","priority":"Medium","source_file":"src/supraluminal_prototype/warp_generator.py","source_file_lines":"70:85","source_snippet":"def plasma_density(self, T): ... def field_propagation(self, F): ...","python_snippet":"import numpy as np\nfrom supraluminal_prototype.warp_generator import WarpFieldGenerator\nxs = np.linspace(-1,1,16)\ngen = WarpFieldGenerator(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nT = gen.build_metric({'r_eff':1e-10,'v':3e8})\nrho = gen.plasma_density(T)\nF = gen.field_propagation(T)\nassert np.allclose(rho, 3e20)\nassert F.shape == (3,16,16,16)"}
{"category":"V&V","task":"Integration test for battery power delivery","priority":"High","source_file":"src/supraluminal_prototype/power_system.py","source_file_lines":"90:100","source_snippet":"def deliver_power(self, P): ...","python_snippet":"import numpy as np\nfrom supraluminal_prototype.power_system import PowerSystem\nP = PowerSystem(capacity=2.56e10)\nP_out = P.deliver_power(2.5e8)\nassert P_out >= 2.5e8\nassert P.capacity_remaining() >= 0"}
{"category":"V&V","task":"Vector impulse energy scales ~ v_max^2","priority":"Medium","source_file":"simulate_vector_impulse.py","source_file_lines":"1:260","source_snippet":"compute_vector_energy_integral","python_snippet":"import numpy as np\nfrom simulate_vector_impulse import Vector3D, VectorImpulseProfile, WarpBubbleVector, simulate_vector_impulse_maneuver\nbase = VectorImpulseProfile(target_displacement=Vector3D(10,0,0), v_max=1e-5, n_steps=200)\nwarp = WarpBubbleVector()\nE1 = simulate_vector_impulse_maneuver(base, warp, enable_progress=False)['total_energy']\nbase.v_max = 2e-5\nE2 = simulate_vector_impulse_maneuver(base, warp, enable_progress=False)['total_energy']\nassert E2 > E1 and E2/E1 > 3.5 and E2/E1 < 4.5"}
{"category":"V&V","task":"Trajectory accuracy improves with n_steps","priority":"Medium","source_file":"integrated_impulse_control.py","source_file_lines":"300:380","source_snippet":"execute_impulse_mission","python_snippet":"from integrated_impulse_control import (IntegratedImpulseController, MissionWaypoint, ImpulseEngineConfig)\nfrom simulate_rotation import Quaternion\nfrom simulate_vector_impulse import Vector3D\nconfig = ImpulseEngineConfig(max_velocity=1e-4, max_angular_velocity=0.1, energy_budget=1e10)\nctl = IntegratedImpulseController(config)\nwp0 = MissionWaypoint(position=Vector3D(0,0,0), orientation=Quaternion(1,0,0,0), dwell_time=0.1)\nwp1 = MissionWaypoint(position=Vector3D(100,0,0), orientation=Quaternion.from_euler(0,0,0), dwell_time=0.1, approach_speed=5e-5)\nplan = ctl.plan_impulse_trajectory([wp0, wp1], optimize_energy=False)\nctl.set_time_steps(100)\nres100 = ctl.execute_impulse_mission(plan, enable_feedback=False)\nctl.set_time_steps(400)\nres400 = ctl.execute_impulse_mission(plan, enable_feedback=False)\nassert res400['trajectory_error'] <= res100['trajectory_error']"}