\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=1in}

\title{Warp Bubble Optimizer: Usage Guide}
\author{Simulation-Focused Warp Engine Framework}
\date{\today}

\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green},
    stringstyle=\color{red},
    breaklines=true,
    frame=single,
    language=Python
}

\begin{document}

\maketitle

\section{Overview}

The Warp Bubble Optimizer provides a comprehensive simulation framework for exploring warp drive physics through numerical optimization and quantum field theory calculations. This guide covers the practical usage of all simulation components.

\section{Quick Start}

\subsection{Basic Setup and GPU Configuration}

Before running any simulations, check GPU availability and JAX configuration:

\begin{lstlisting}
# Check GPU and JAX acceleration capabilities
python gpu_check.py

# Run comprehensive system diagnostics
python gpu_check.py --detailed
\end{lstlisting}

The system automatically falls back to CPU computation if GPU is unavailable, with comprehensive logging of the fallback process.

\subsection{Shape Function Optimization}

The core shape optimization with Quantum Inequality (QI) constraints:

\begin{lstlisting}
# Basic shape optimization with QI enforcement
python optimize_shape.py --ansatz gaussian --constraint-weight 0.8

# Advanced optimization with custom parameters
python advanced_shape_optimizer.py --ansatz soliton \
    --mu 0.5 --sigma 1.2 --constraint-weight 1.0 \
    --boundary-weight 0.3 --visualize
\end{lstlisting}

\subsection{Real-Time Control Loop Simulation}

Simulate closed-loop warp field control:

\begin{lstlisting}
# Run virtual control loop simulation
python sim_control_loop.py --duration 100 --timestep 0.01

# Control loop with disturbance simulation
python sim_control_loop.py --enable-disturbance \
    --noise-level 0.05 --adaptive-gains
\end{lstlisting}

\section{JAX Acceleration Framework}

\subsection{GPU/CPU Fallback Logic}

The system implements robust fallback logic:

\begin{enumerate}
\item \textbf{GPU Detection}: Automatic CUDA/OpenCL detection with device enumeration
\item \textbf{Memory Validation}: GPU memory requirements checked against available VRAM
\item \textbf{Graceful Fallback}: Seamless transition to optimized CPU computation
\item \textbf{Performance Monitoring}: Real-time performance metrics and device utilization
\end{enumerate}

\subsection{JAX Demo Scripts}

Demonstrate acceleration capabilities:

\begin{lstlisting}
# Test JAX acceleration on Einstein tensor computations
python demo_jax_warp_acceleration.py

# 4D spacetime optimization with JAX
python jax_4d_optimizer.py --resolution 64 --steps 1000

# Gaussian waveform optimization
python gaussian_optimize_jax.py --sigma-range 0.5,2.0
\end{lstlisting}

\section{Visualization and Analysis}

\subsection{3D Bubble Visualization}

Generate comprehensive metric visualizations:

\begin{lstlisting}
# Create 3D warp bubble visualization
python visualize_bubble.py --ansatz lentz --mu 0.8 \
    --resolution 128 --save-format png

# Interactive visualization with field components
python visualize_bubble.py --interactive \
    --show-energy-density --show-stress-tensor
\end{lstlisting}

\subsection{Analysis Tools}

\begin{lstlisting}
# Analyze optimization results
python analyze_results.py --input breakthrough_results.json

# Energy scaling analysis
python analyze_m8_breakthrough.py --focus-scaling
\end{lstlisting}

\section{Advanced Features}

\subsection{Multi-Strategy Optimization}

Run comprehensive optimization campaigns:

\begin{lstlisting}
# Multi-strategy optimizer with Bayesian optimization
python advanced_multi_strategy_optimizer.py \
    --strategies gaussian,soliton,lentz \
    --parallel-jobs 4 --max-iterations 500

# B-spline optimization with advanced constraints
python advanced_bspline_optimizer.py \
    --control-points 16 --smoothness-weight 0.2
\end{lstlisting}

\subsection{Analog Hardware Simulation}

Simulate analog control hardware in software:

\begin{lstlisting}
# Run analog prototype simulation
python analog_sim.py --control-bandwidth 1000 \
    --field-resolution 256 --real-time-factor 0.1

# Test analog PID controller responses
python analog_sim.py --test-pid --gain-sweep
\end{lstlisting}

\section{Progress Tracking and Monitoring}

\subsection{ProgressTracker Integration}

All long-running simulations integrate the ProgressTracker utility:

\begin{lstlisting}
from progress_tracker import ProgressTracker, MultiProcessProgressTracker

# Single-process tracking
tracker = ProgressTracker(10, "Warp Field Optimization")
tracker.start({'ansatz': 'gaussian', 'constraints': 'QI+boundary'})

# Multi-process distributed tracking
mp_tracker = MultiProcessProgressTracker()
mp_tracker.add_process("worker_1", 5, "Einstein Tensor Computation")
mp_tracker.add_process("worker_2", 8, "Stress Tensor Analysis")
\end{lstlisting}

\subsection{Performance Monitoring}

Track system performance across subsystems:

\begin{itemize}
\item Real-time step duration and ETA calculation
\item Memory usage and GPU utilization monitoring
\item Error and warning aggregation with context
\item Detailed performance metrics export
\end{itemize}

\section{Quantum Inequality Constraints}

\subsection{QI Enforcement}

The system enforces averaged null energy conditions:

\begin{equation}
\langle T_{\mu\nu} k^\mu k^\nu \rangle \geq -\frac{\hbar c}{A} f(\tau)
\end{equation}

Where $f(\tau)$ is implemented as a regularization function with configurable parameters.

\subsection{Constraint Configuration}

\begin{lstlisting}
# Configure QI constraints in qi_constraint.py
qi_params = {
    'constraint_weight': 1.0,      # Lagrange multiplier strength
    'regularization_scale': 0.1,   # Regularization parameter
    'sampling_points': 64,         # Null geodesic sampling density
    'tolerance': 1e-8              # Constraint violation tolerance
}
\end{lstlisting}

\section{Full Engine Demonstration}

Run the complete warp engine simulation:

\begin{lstlisting}
# Complete demonstration with all subsystems
python run_full_warp_engine.py --demo

# Individual subsystem testing
python run_full_warp_engine.py --step 1  # Back-reaction analysis
python run_full_warp_engine.py --step 2  # Field optimization
python run_full_warp_engine.py --step 3  # Control simulation

# Performance benchmarking
python run_full_warp_engine.py --benchmark --device gpu
\end{lstlisting}

\section{Configuration and Customization}

\subsection{System Configuration}

Key configuration files and parameters:

\begin{itemize}
\item \texttt{gpu\_config.json}: GPU device preferences and memory limits
\item \texttt{optimization\_params.yaml}: Default optimization parameters
\item \texttt{qi\_constraints.json}: Quantum inequality constraint settings
\item \texttt{visualization\_config.py}: Plotting and rendering preferences
\end{itemize}

\subsection{Custom Ansatz Development}

Implement custom warp bubble ansatz functions:

\begin{lstlisting}
# Example custom ansatz in advanced_shape_optimizer.py
def custom_ansatz(coords, params):
    """Custom warp bubble shape function."""
    x, y, z, t = coords
    mu, sigma, amplitude = params
    
    # Implement custom geometric profile
    r = jnp.sqrt(x**2 + y**2 + z**2)
    profile = amplitude * jnp.exp(-r**2/(2*sigma**2))
    
    return profile * smooth_cutoff(r, mu)
\end{lstlisting}

\section{Troubleshooting}

\subsection{Common Issues}

\begin{enumerate}
\item \textbf{GPU Memory Errors}: Reduce resolution or batch size
\item \textbf{Convergence Issues}: Adjust constraint weights and learning rates
\item \textbf{Numerical Instabilities}: Enable higher precision or regularization
\item \textbf{Performance Bottlenecks}: Check device utilization and memory bandwidth
\end{enumerate}

\subsection{Debug Mode}

Enable comprehensive debugging:

\begin{lstlisting}
# Enable debug logging across all subsystems
export WARP_DEBUG=1
export JAX_DEBUG_NANS=1
export JAX_DISABLE_JIT=1  # For debugging compiled functions

# Run with enhanced error reporting
python optimize_shape.py --debug --verbose
\end{lstlisting}

\section{Output Interpretation}

\subsection{Optimization Results}

Key metrics to monitor:

\begin{itemize}
\item \textbf{Energy Density}: Peak and integrated negative energy requirements
\item \textbf{QI Violation}: Quantified constraint violations with spatial distribution
\item \textbf{Convergence Rate}: Optimization convergence and stability metrics
\item \textbf{Field Gradients}: Spatial field variations and singularity analysis
\end{itemize}

\subsection{Visualization Outputs}

Standard output formats:

\begin{itemize}
\item \texttt{*.png}: High-resolution static visualizations
\item \texttt{*.mp4}: Time-evolution animations
\item \texttt{*.json}: Numerical results and metadata
\item \texttt{*.h5}: Large-scale simulation data archives
\end{itemize}

\end{document}
