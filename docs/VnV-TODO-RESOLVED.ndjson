{"category":"V&V","task":"Backreaction analyzer timeout path","priority":"Done","source_file":"src/warp_engine/backreaction.py","source_file_lines":"1:200","source_snippet":"analyze_backreaction_coupling(..., timeout_s)","python_snippet":"from warp_engine.backreaction import analyze_backreaction_coupling as f; assert callable(f)","status":"resolved","date":"2025-08-10"}
{"category":"V&V","task":"Ultimate B-Spline import and objective smoke","priority":"Done","source_file":"src/optimization/ultimate_bspline_optimizer.py","source_file_lines":"1:420","source_snippet":"objective_function_core","python_snippet":"from ultimate_bspline_optimizer import UltimateBSplineOptimizer as U; U().objective_function(U().initialize_parameters())","status":"resolved","date":"2025-08-10"}
{"category":"V&V","task":"Nat√°rio build_metric divergence-free shift","priority":"Done","source_file":"src/supraluminal_prototype/warp_generator.py","source_file_lines":"1:120","source_snippet":"build_metric, expansion_scalar","python_snippet":"from src.supraluminal_prototype.warp_generator import GridSpec, build_metric, expansion_scalar; m=build_metric({'grid':GridSpec()}); th=expansion_scalar(m); import numpy as np; assert float(np.mean(np.abs(th)))<5e-3","status":"resolved","date":"2025-08-09"}
{"category":"V&V","task":"Vector impulse energy scales ~ v_max^2","priority":"Done","source_file":"simulate_vector_impulse.py","source_file_lines":"1:260","source_snippet":"compute_vector_energy_integral","python_snippet":"from simulate_vector_impulse import Vector3D, VectorImpulseProfile, WarpBubbleVector, simulate_vector_impulse_maneuver; base=VectorImpulseProfile(target_displacement=Vector3D(10,0,0), v_max=1e-5, n_steps=200); import numpy as np; import numpy as _np; warp=WarpBubbleVector(shape_params=_np.array([1.0,2.0,0.5])); E1=simulate_vector_impulse_maneuver(base, warp, enable_progress=False)['total_energy']; base.v_max=2e-5; E2=simulate_vector_impulse_maneuver(base, warp, enable_progress=False)['total_energy']; assert E2>E1 and 3.3<E2/(E1+1e-30)<4.7","status":"resolved","date":"2025-08-09"}
{"category":"V&V","task":"Trajectory accuracy improves with n_steps","priority":"Done","source_file":"integrated_impulse_control.py","source_file_lines":"300:380","source_snippet":"execute_impulse_mission (vector path)","python_snippet":"from simulate_vector_impulse import Vector3D, VectorImpulseProfile, WarpBubbleVector, simulate_vector_impulse_maneuver; import numpy as _np; target=Vector3D(100,0,0); warp=WarpBubbleVector(shape_params=_np.array([1.0,2.0,0.5])); c=VectorImpulseProfile(target_displacement=target,v_max=5e-5,t_up=5,t_hold=10,t_down=5,n_steps=100); f=VectorImpulseProfile(target_displacement=target,v_max=5e-5,t_up=5,t_hold=10,t_down=5,n_steps=400); rc=simulate_vector_impulse_maneuver(c, warp, enable_progress=False); rf=simulate_vector_impulse_maneuver(f, warp, enable_progress=False); assert rf['trajectory_error']<=rc['trajectory_error']*1.05","status":"resolved","date":"2025-08-09"}
