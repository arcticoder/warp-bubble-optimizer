{"category":"V&V","task":"V&V: ring phase error < threshold under disturbances","priority":"High","source_file":"src/supraluminal_prototype/control.py","source_snippet":"def sync_rings","python_snippet":"# Placeholder: simulate phase disturbances and ensure phase spread <= threshold"}
{"category":"V&V","task":"V&V: numeric reproduction within tolerance","priority":"High","source_file":"scripts/reproduce_soliton_report.py","source_snippet":"def reproduce","python_snippet":"# Placeholder: load outputs and assert within tolerance vs reported values"}
{"category":"V&V","task":"HIL: end-to-end power draw within 10% of model","priority":"High","source_file":"src/supraluminal_prototype/power.py","source_snippet":"def compute_smearing_energy","python_snippet":"# Placeholder integration note: compare logged P(t) vs model over ramp/cruise/ramps; compute MAPE and assert <10%"}
{"category":"V&V","task":"Closed-loop phase stability > 6 dB margin","priority":"High","source_file":"src/supraluminal_prototype/control.py","source_snippet":"def sync_rings","python_snippet":"# Placeholder: derive loop transfer L(jw) and ensure |L| margin > 6 dB at crossover; assert margin_db >= 6"}
{"category":"V&V","task":"Dry-run mission rehearsal with simulated telemetry","priority":"Medium","source_file":"scripts/mission_rehearsal.py","source_snippet":"def run_rehearsal","python_snippet":"# Placeholder: run dry-run generating synthetic telemetry; assert key event timestamps within planned windows"}
{"category":"Docs/Process","task":"Traceability: link roadmap items to tests","priority":"High","source_file":"docs/roadmap.ndjson","source_snippet":"associated_tasks","python_snippet":"# Scriptable check: for each associated_tasks title, ensure a matching line exists in VnV-TODO.ndjson/UQ-TODO.ndjson/tests"}
{"category":"Docs/Process","task":"Finalize requirements spec v1.0","priority":"High","source_file":"docs/requirements.md","source_snippet":"Mission requirements","python_snippet":"# Placeholder: validate document completeness checklist; assert all MUST-level items present"}
{"category":"Safety","task":"Safety checklist v0.9","priority":"High","source_file":"docs/safety_checklist.md","source_snippet":"Safe ramp abort and quench procedures","python_snippet":"# Placeholder: validate presence of abort criteria, watchdogs, thermal margins"}
{"category":"V&V","task":"V&V: coil ramp linearity and hysteresis","priority":"Medium","source_file":"src/supraluminal_prototype/hardware.py","source_snippet":"class CoilDriver","python_snippet":"from src.supraluminal_prototype.hardware import CoilDriver\ndrv = CoilDriver(max_current=5000.0, hysteresis=0.0)\nvals = [drv.command(i/30.0) for i in range(31)]\n# Near-linear increments\nincs = [vals[i]-vals[i-1] for i in range(1,31)]\nassert max(abs(incs[i]-incs[0]) for i in range(1,len(incs))) < 1e-3*drv.max_current"}
{"category":"V&V","task":"V&V: power draw vs. model across ramp","priority":"High","source_file":"src/supraluminal_prototype/power.py","source_snippet":"def compute_smearing_energy","python_snippet":"# Placeholder: integrate measured P(t) and compare to model E within tolerance; assert abs(E_meas-E_model)/E_model < 0.1"}
{"category":"Design","task":"Power electronics block diagram v1","priority":"Medium","source_file":"docs/power_electronics_block.md","source_snippet":"DC bus, ring drivers, protections","python_snippet":"# Placeholder artifact existence check"}
{"task":"Instantiate MetricBackreactionEvolution with default parameters","priority":"High","source_file":"evolve_3plus1D_with_backreaction.py","source_file_lines":"1:20","source_snippet":"class MetricBackreactionEvolution","python_snippet":"from evolve_3plus1D_with_backreaction import MetricBackreactionEvolution; mbe = MetricBackreactionEvolution(); assert hasattr(mbe, 'laplacian_3d') and callable(mbe.laplacian_3d)"}
{"task":"Validate laplacian_3d finite-difference implementation","priority":"Medium","source_file":"evolve_3plus1D_with_backreaction.py","source_file_lines":"40:70","source_snippet":"def laplacian_3d(self, field):","python_snippet":"import numpy as np; from evolve_3plus1D_with_backreaction import MetricBackreactionEvolution; mbe = MetricBackreactionEvolution(grid_size=(10,10,10)); f = np.ones((10,10,10)); lap = mbe.laplacian_3d(f); assert np.allclose(lap, 0)"}
{"task":"Check stress_energy_tensor returns expected keys and shapes","priority":"High","source_file":"evolve_3plus1D_with_backreaction.py","source_file_lines":"140:170","source_snippet":"def stress_energy_tensor(self, phi, pi):","python_snippet":"import numpy as np; from evolve_3plus1D_with_backreaction import MetricBackreactionEvolution; mbe = MetricBackreactionEvolution(grid_size=(8,8,8)); phi = np.zeros((8,8,8)); pi = np.zeros_like(phi); T = mbe.stress_energy_tensor(phi, pi); assert all(k in T for k in ['T_00','T_11','T_22','T_33']); assert T['T_00'].shape == (8,8,8)"}
# V&V tasks for compute_negative_energy_region
{"task":"Validate compute_negative_energy_region returns expected dictionary keys","source_file":"src/warp_qft/negative_energy.py","source_file_lines":"300:330","source_snippet":"def compute_negative_energy_region","python_snippet":"from warp_qft.negative_energy import compute_negative_energy_region\nres = compute_negative_energy_region(16,0.5)\nassert isinstance(res,dict)\nfor key in ['total_negative_energy','peak_location','region_mask']: assert key in res"}
{"task":"Integration test for compute_negative_energy_region with classical case returns zero negative energy","source_file":"src/warp_qft/negative_energy.py","source_file_lines":"300:330","source_snippet":"def compute_negative_energy_region","python_snippet":"import numpy as np\nfrom warp_qft.negative_energy import compute_negative_energy_region\nres = compute_negative_energy_region(4,0.0)\nassert np.isclose(res.get('total_negative_energy',0),0.0)"}
{"category":"V&V","task":"Unit test temporal smearing energy model for linear ramp cases","priority":"High","source_file":"src/supraluminal_prototype/power.py","source_snippet":"def compute_smearing_energy","python_snippet":"from supraluminal_prototype.power import compute_smearing_energy\nE = compute_smearing_energy(25e6, 30.0, 2.56)\nassert E > 0"}
{"category":"V&V","task":"Validate field_synthesis bounds and normalization","priority":"High","source_file":"src/supraluminal_prototype/warp_generator.py","source_snippet":"def field_synthesis","python_snippet":"from supraluminal_prototype.warp_generator import field_synthesis, GridSpec\nres = field_synthesis([1,0.5,0.5,0.2], {'grid': GridSpec()})\nenv = res['envelope']\nassert env.min() >= 0 and env.max() <= 1+1e-9"}
{"category":"V&V","task":"Check Natário zero-expansion after envelope coupling (curl(e*A))","priority":"High","source_file":"src/supraluminal_prototype/warp_generator.py","source_snippet":"def synthesize_shift_with_envelope","python_snippet":"from supraluminal_prototype.warp_generator import synthesize_shift_with_envelope, expansion_scalar, GridSpec\nres = synthesize_shift_with_envelope({'grid': GridSpec(), 'R':2.5, 'sigma':0.2, 'ring_controls':[1,1,1,1]})\nimport numpy as np\nassert np.nanmax(np.abs(expansion_scalar(res))) < 5e-2"}
{"category":"V&V","task":"Optimize energy stub returns positive energy and shaped controls","priority":"Medium","source_file":"src/supraluminal_prototype/warp_generator.py","source_snippet":"def optimize_energy","python_snippet":"from supraluminal_prototype.warp_generator import optimize_energy, GridSpec\nout = optimize_energy({'grid': GridSpec(), 'P_peak':25e6, 't_ramp':30.0, 't_cruise':2.56})\nassert out['E']>0 and out['best_controls'].shape==(4,) and out['fit_error']>=0"}
{"category":"V&V","task":"3D stability analyzer smoke test (import and instantiate)","priority":"Low","source_file":"test_3d_stability.py","source_snippet":"class WarpBubble3DStabilityAnalyzer","python_snippet":"from test_3d_stability import WarpBubble3DStabilityAnalyzer\na = WarpBubble3DStabilityAnalyzer()\nassert a.nr>0"}
{"category":"V&V","task":"Validate temporal smearing energy model against analytic triangle/linear ramps","priority":"High","source_file":"src/supraluminal_prototype/power.py","source_file_lines":"1:120","source_snippet":"def compute_smearing_energy(P_peak, t_ramp, t_cruise, shape='linear')","python_snippet":"from supraluminal_prototype.power import compute_smearing_energy\nE30 = compute_smearing_energy(25e6, 30.0, 2.56)\nE120 = compute_smearing_energy(25e6, 120.0, 2.56)\nassert E30 < E120"}
{"category":"V&V","task":"Check Natário zero-expansion condition for build_metric output","priority":"High","source_file":"src/supraluminal_prototype/warp_generator.py","source_file_lines":"1:160","source_snippet":"def build_metric(params):","python_snippet":"import numpy as np\nfrom supraluminal_prototype.warp_generator import build_metric, expansion_scalar\nmetric = build_metric({'R':2.5})\ntheta = expansion_scalar(metric)\nassert np.allclose(theta, 0, atol=1e-6)"}
{"category":"V&V","task":"Coil ramp profile linearity and hysteresis test harness","priority":"Medium","source_file":"src/supraluminal_prototype/hardware.py","source_file_lines":"1:120","source_snippet":"class CoilDriver","python_snippet":"from supraluminal_prototype.hardware import CoilDriver\ndrv = CoilDriver(max_current=5e3)\nI = [drv.command(i/30.0) for i in range(31)]\nassert max(abs((I[i]-I[i-1])-(I[1]-I[0])) for i in range(2,31)) < 1e-3"}
{"category":"V&V","task":"Ring synchronization tolerance test (phase jitter budget)","priority":"Medium","source_file":"src/supraluminal_prototype/control.py","source_file_lines":"1:160","source_snippet":"def sync_rings(phases, jitter):","python_snippet":"import numpy as np\nfrom supraluminal_prototype.control import sync_rings\nphases = np.array([0.0, 0.0, 0.0, 0.0])\nok = sync_rings(phases, jitter=1e-6)\nassert ok is True"}
{"category":"V&V","task":"Reproduce prior soliton energy figure within tolerance","priority":"High","source_file":"docs/SOLITON_PROJECT_FINAL_REPORT.md","source_file_lines":"1:200","source_snippet":"Best negative energy achieved","python_snippet":"# Load reproduction script outputs and compare to reported -1.584e31 J within ±5%\nimport json, math\nwith open('results/soliton_reproduction.json') as f: d=json.load(f)\nassert math.isclose(d['best_negative_energy'], -1.584e31, rel_tol=0.05)"}
{"category":"V&V","task":"Power budget numeric reconciliation","priority":"High","source_file":"docs/","source_file_lines":"-","source_snippet":"Temporal smearing section numbers","python_snippet":"# Verify E_total = 2*(0.5*t_ramp*P_peak)+P_peak*t_cruise across scenarios\n# Raise if differs from documented values by >10% to trigger doc update"}
{"task":"Verify build_metric for Natário metric with 1-meter rings","priority":"High","source_file":"src/supraluminal_prototype/warp_generator.py","source_file_lines":"50:65","source_snippet":"def build_metric(self, params): ...","python_snippet":"import numpy as np\nfrom supraluminal_prototype.warp_generator import WarpFieldGenerator\nxs = np.linspace(-1,1,16)\ngen = WarpFieldGenerator(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nG = gen.build_metric({'r_eff':1e-10,'v':3e8})\nassert G.shape == (4,4,16,16,16)\nr2 = sum(xi**2 for xi in np.meshgrid(xs,xs,xs,indexing='ij'))\nassert np.allclose(G[0,0], np.exp(-r2))"}
{"task":"Test plasma_density and field_propagation for 5-meter bubble","priority":"Medium","source_file":"src/supraluminal_prototype/warp_generator.py","source_file_lines":"70:85","source_snippet":"def plasma_density(self, T): ... def field_propagation(self, F): ...","python_snippet":"import numpy as np\nfrom supraluminal_prototype.warp_generator import WarpFieldGenerator\nxs = np.linspace(-1,1,16)\ngen = WarpFieldGenerator(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nT = gen.build_metric({'r_eff':1e-10,'v':3e8})\nrho = gen.plasma_density(T)\nF = gen.field_propagation(T)\nassert np.allclose(rho, 3e20)\nassert F.shape == (3,16,16,16)"}
{"category":"V&V","task":"Integration test for battery power delivery","priority":"High","source_file":"src/supraluminal_prototype/power_system.py","source_file_lines":"90:100","source_snippet":"def deliver_power(self, P): ...","python_snippet":"import numpy as np\nfrom supraluminal_prototype.power_system import PowerSystem\nP = PowerSystem(capacity=2.56e10)\nP_out = P.deliver_power(2.5e8)\nassert P_out >= 2.5e8\nassert P.capacity_remaining() >= 0"}
{"category":"V&V","task":"Validate plasma_density bounds and units","priority":"High","source_file":"src/supraluminal_prototype/warp_generator.py","source_snippet":"def plasma_density","python_snippet":"import numpy as np\nfrom src.supraluminal_prototype.warp_generator import plasma_density, GridSpec\nres = plasma_density({'grid': GridSpec(), 'n0': 3e20})\nn = res['n']\nassert float(n.min()) >= 0 and np.isfinite(n).all()\n# units: n0 is in m^-3; ensure scaling preserves peak within ~1%\nassert np.isclose(float(n.max()), 3e20, rtol=1e-2)"}
{"category":"V&V","task":"Bench field_synthesis against simplified analytic target","priority":"Medium","source_file":"src/supraluminal_prototype/warp_generator.py","source_snippet":"def field_synthesis","python_snippet":"import numpy as np\nfrom src.supraluminal_prototype.warp_generator import GridSpec, field_synthesis, target_soliton_envelope, compute_envelope_error\ngrid = GridSpec()\n# Use target_soliton_envelope as simplified analytic target\nanalytic = target_soliton_envelope({'grid': grid, 'r0': 0.0, 'sigma': 0.5*grid.extent})['envelope']\n# Synthesize with uniform ring amplitudes and reasonable sigma\nsyn = field_synthesis([1,1,1,1], {'grid': grid, 'sigma': 0.2*grid.extent})['envelope']\nerr = compute_envelope_error(syn, analytic, norm='l2')\n# Expect bounded error on coarse grid; tighten later with fitters\nassert 0.0 <= err <= 0.6"}
