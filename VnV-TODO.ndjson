{"task":"Instantiate MetricBackreactionEvolution with default parameters","priority":"High","source_file":"evolve_3plus1D_with_backreaction.py","source_file_lines":"1:20","source_snippet":"class MetricBackreactionEvolution","python_snippet":"from evolve_3plus1D_with_backreaction import MetricBackreactionEvolution; mbe = MetricBackreactionEvolution(); assert hasattr(mbe, 'laplacian_3d') and callable(mbe.laplacian_3d)"}
{"task":"Validate laplacian_3d finite-difference implementation","priority":"Medium","source_file":"evolve_3plus1D_with_backreaction.py","source_file_lines":"40:70","source_snippet":"def laplacian_3d(self, field):","python_snippet":"import numpy as np; from evolve_3plus1D_with_backreaction import MetricBackreactionEvolution; mbe = MetricBackreactionEvolution(grid_size=(10,10,10)); f = np.ones((10,10,10)); lap = mbe.laplacian_3d(f); assert np.allclose(lap, 0)"}
{"task":"Check stress_energy_tensor returns expected keys and shapes","priority":"High","source_file":"evolve_3plus1D_with_backreaction.py","source_file_lines":"140:170","source_snippet":"def stress_energy_tensor(self, phi, pi):","python_snippet":"import numpy as np; from evolve_3plus1D_with_backreaction import MetricBackreactionEvolution; mbe = MetricBackreactionEvolution(grid_size=(8,8,8)); phi = np.zeros((8,8,8)); pi = np.zeros_like(phi); T = mbe.stress_energy_tensor(phi, pi); assert all(k in T for k in ['T_00','T_11','T_22','T_33']); assert T['T_00'].shape == (8,8,8)"}
# V&V tasks for compute_negative_energy_region
{"task":"Validate compute_negative_energy_region returns expected dictionary keys","source_file":"src/warp_qft/negative_energy.py","source_file_lines":"300:330","source_snippet":"def compute_negative_energy_region","python_snippet":"from warp_qft.negative_energy import compute_negative_energy_region\nres = compute_negative_energy_region(16,0.5)\nassert isinstance(res,dict)\nfor key in ['total_negative_energy','peak_location','region_mask']: assert key in res"}
{"task":"Integration test for compute_negative_energy_region with classical case returns zero negative energy","source_file":"src/warp_qft/negative_energy.py","source_file_lines":"300:330","source_snippet":"def compute_negative_energy_region","python_snippet":"import numpy as np\nfrom warp_qft.negative_energy import compute_negative_energy_region\nres = compute_negative_energy_region(4,0.0)\nassert np.isclose(res.get('total_negative_energy',0),0.0)"}
{"category":"V&V","task":"Unit test temporal smearing energy model for linear ramp cases","priority":"High","source_file":"src/supraluminal_prototype/power.py","source_snippet":"def compute_smearing_energy","python_snippet":"from supraluminal_prototype.power import compute_smearing_energy\nE = compute_smearing_energy(25e6, 30.0, 2.56)\nassert E > 0"}
{"category":"V&V","task":"Validate field_synthesis bounds and normalization","priority":"High","source_file":"src/supraluminal_prototype/warp_generator.py","source_snippet":"def field_synthesis","python_snippet":"from supraluminal_prototype.warp_generator import field_synthesis, GridSpec\nres = field_synthesis([1,0.5,0.5,0.2], {'grid': GridSpec()})\nenv = res['envelope']\nassert env.min() >= 0 and env.max() <= 1+1e-9"}
{"category":"V&V","task":"Check Natário zero-expansion after envelope coupling (curl(e*A))","priority":"High","source_file":"src/supraluminal_prototype/warp_generator.py","source_snippet":"def synthesize_shift_with_envelope","python_snippet":"from supraluminal_prototype.warp_generator import synthesize_shift_with_envelope, expansion_scalar, GridSpec\nres = synthesize_shift_with_envelope({'grid': GridSpec(), 'R':2.5, 'sigma':0.2, 'ring_controls':[1,1,1,1]})\nimport numpy as np\nassert np.nanmax(np.abs(expansion_scalar(res))) < 5e-2"}
{"category":"V&V","task":"Optimize energy stub returns positive energy and shaped controls","priority":"Medium","source_file":"src/supraluminal_prototype/warp_generator.py","source_snippet":"def optimize_energy","python_snippet":"from supraluminal_prototype.warp_generator import optimize_energy, GridSpec\nout = optimize_energy({'grid': GridSpec(), 'P_peak':25e6, 't_ramp':30.0, 't_cruise':2.56})\nassert out['E']>0 and out['best_controls'].shape==(4,) and out['fit_error']>=0"}
{"category":"V&V","task":"3D stability analyzer smoke test (import and instantiate)","priority":"Low","source_file":"test_3d_stability.py","source_snippet":"class WarpBubble3DStabilityAnalyzer","python_snippet":"from test_3d_stability import WarpBubble3DStabilityAnalyzer\na = WarpBubble3DStabilityAnalyzer()\nassert a.nr>0"}
{"category":"V&V","task":"Validate temporal smearing energy model against analytic triangle/linear ramps","priority":"High","source_file":"src/supraluminal_prototype/power.py","source_file_lines":"1:120","source_snippet":"def compute_smearing_energy(P_peak, t_ramp, t_cruise, shape='linear')","python_snippet":"from supraluminal_prototype.power import compute_smearing_energy\nE30 = compute_smearing_energy(25e6, 30.0, 2.56)\nE120 = compute_smearing_energy(25e6, 120.0, 2.56)\nassert E30 < E120"}
{"category":"V&V","task":"Check Natário zero-expansion condition for build_metric output","priority":"High","source_file":"src/supraluminal_prototype/warp_generator.py","source_file_lines":"1:160","source_snippet":"def build_metric(params):","python_snippet":"import numpy as np\nfrom supraluminal_prototype.warp_generator import build_metric, expansion_scalar\nmetric = build_metric({'R':2.5})\ntheta = expansion_scalar(metric)\nassert np.allclose(theta, 0, atol=1e-6)"}
{"category":"V&V","task":"Coil ramp profile linearity and hysteresis test harness","priority":"Medium","source_file":"src/supraluminal_prototype/hardware.py","source_file_lines":"1:120","source_snippet":"class CoilDriver","python_snippet":"from supraluminal_prototype.hardware import CoilDriver\ndrv = CoilDriver(max_current=5e3)\nI = [drv.command(i/30.0) for i in range(31)]\nassert max(abs((I[i]-I[i-1])-(I[1]-I[0])) for i in range(2,31)) < 1e-3"}
{"category":"V&V","task":"Ring synchronization tolerance test (phase jitter budget)","priority":"Medium","source_file":"src/supraluminal_prototype/control.py","source_file_lines":"1:160","source_snippet":"def sync_rings(phases, jitter):","python_snippet":"import numpy as np\nfrom supraluminal_prototype.control import sync_rings\nphases = np.array([0.0, 0.0, 0.0, 0.0])\nok = sync_rings(phases, jitter=1e-6)\nassert ok is True"}
{"category":"V&V","task":"Reproduce prior soliton energy figure within tolerance","priority":"High","source_file":"docs/SOLITON_PROJECT_FINAL_REPORT.md","source_file_lines":"1:200","source_snippet":"Best negative energy achieved","python_snippet":"# Load reproduction script outputs and compare to reported -1.584e31 J within ±5%\nimport json, math\nwith open('results/soliton_reproduction.json') as f: d=json.load(f)\nassert math.isclose(d['best_negative_energy'], -1.584e31, rel_tol=0.05)"}
{"category":"V&V","task":"Power budget numeric reconciliation","priority":"High","source_file":"docs/","source_file_lines":"-","source_snippet":"Temporal smearing section numbers","python_snippet":"# Verify E_total = 2*(0.5*t_ramp*P_peak)+P_peak*t_cruise across scenarios\n# Raise if differs from documented values by >10% to trigger doc update"}
{"task":"Verify build_metric for Natário metric with 1-meter rings","priority":"High","source_file":"src/supraluminal_prototype/warp_generator.py","source_file_lines":"50:65","source_snippet":"def build_metric(self, params): ...","python_snippet":"import numpy as np\nfrom supraluminal_prototype.warp_generator import WarpFieldGenerator\nxs = np.linspace(-1,1,16)\ngen = WarpFieldGenerator(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nG = gen.build_metric({'r_eff':1e-10,'v':3e8})\nassert G.shape == (4,4,16,16,16)\nr2 = sum(xi**2 for xi in np.meshgrid(xs,xs,xs,indexing='ij'))\nassert np.allclose(G[0,0], np.exp(-r2))"}
{"task":"Test plasma_density and field_propagation for 5-meter bubble","priority":"Medium","source_file":"src/supraluminal_prototype/warp_generator.py","source_file_lines":"70:85","source_snippet":"def plasma_density(self, T): ... def field_propagation(self, F): ...","python_snippet":"import numpy as np\nfrom supraluminal_prototype.warp_generator import WarpFieldGenerator\nxs = np.linspace(-1,1,16)\ngen = WarpFieldGenerator(grid=(xs, xs, xs), dx=xs[1]-xs[0])\nT = gen.build_metric({'r_eff':1e-10,'v':3e8})\nrho = gen.plasma_density(T)\nF = gen.field_propagation(T)\nassert np.allclose(rho, 3e20)\nassert F.shape == (3,16,16,16)"}
{"category":"V&V","task":"Integration test for battery power delivery","priority":"High","source_file":"src/supraluminal_prototype/power_system.py","source_file_lines":"90:100","source_snippet":"def deliver_power(self, P): ...","python_snippet":"import numpy as np\nfrom supraluminal_prototype.power_system import PowerSystem\nP = PowerSystem(capacity=2.56e10)\nP_out = P.deliver_power(2.5e8)\nassert P_out >= 2.5e8\nassert P.capacity_remaining() >= 0"}
{"category":"V&V","task":"Vector impulse energy scales ~ v_max^2","priority":"Done","note":"Implemented in tests/test_vnv_vector_impulse.py"}
{"category":"V&V","task":"Trajectory accuracy improves with n_steps","priority":"Done","note":"Implemented in tests/test_vnv_vector_impulse.py"}