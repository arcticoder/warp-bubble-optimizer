{"task":"Instantiate MetricBackreactionEvolution with default parameters","priority":"High","source_file":"evolve_3plus1D_with_backreaction.py","source_file_lines":"1:20","source_snippet":"class MetricBackreactionEvolution","python_snippet":"from evolve_3plus1D_with_backreaction import MetricBackreactionEvolution; mbe = MetricBackreactionEvolution(); assert hasattr(mbe, 'laplacian_3d') and callable(mbe.laplacian_3d)"}
{"task":"Validate laplacian_3d finite-difference implementation","priority":"Medium","source_file":"evolve_3plus1D_with_backreaction.py","source_file_lines":"40:70","source_snippet":"def laplacian_3d(self, field):","python_snippet":"import numpy as np; from evolve_3plus1D_with_backreaction import MetricBackreactionEvolution; mbe = MetricBackreactionEvolution(grid_size=(10,10,10)); f = np.ones((10,10,10)); lap = mbe.laplacian_3d(f); assert np.allclose(lap, 0)"}
{"task":"Check stress_energy_tensor returns expected keys and shapes","priority":"High","source_file":"evolve_3plus1D_with_backreaction.py","source_file_lines":"140:170","source_snippet":"def stress_energy_tensor(self, phi, pi):","python_snippet":"import numpy as np; from evolve_3plus1D_with_backreaction import MetricBackreactionEvolution; mbe = MetricBackreactionEvolution(grid_size=(8,8,8)); phi = np.zeros((8,8,8)); pi = np.zeros_like(phi); T = mbe.stress_energy_tensor(phi, pi); assert all(k in T for k in ['T_00','T_11','T_22','T_33']); assert T['T_00'].shape == (8,8,8)"}
# V&V tasks for compute_negative_energy_region
{"task":"Validate compute_negative_energy_region returns expected dictionary keys","source_file":"src/warp_qft/negative_energy.py","source_file_lines":"300:330","source_snippet":"def compute_negative_energy_region","python_snippet":"from warp_qft.negative_energy import compute_negative_energy_region\nres = compute_negative_energy_region(16,0.5)\nassert isinstance(res,dict)\nfor key in ['total_negative_energy','peak_location','region_mask']: assert key in res"}
{"task":"Integration test for compute_negative_energy_region with classical case returns zero negative energy","source_file":"src/warp_qft/negative_energy.py","source_file_lines":"300:330","source_snippet":"def compute_negative_energy_region","python_snippet":"import numpy as np\nfrom warp_qft.negative_energy import compute_negative_energy_region\nres = compute_negative_energy_region(4,0.0)\nassert np.isclose(res.get('total_negative_energy',0),0.0)"}